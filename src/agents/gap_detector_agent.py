from .base_agent import BaseAgent
from crawlers.dynamic_crawler import DynamicCrawler
from duckduckgo_search import DDGS

class GapDetectorAgent(BaseAgent):
    def __init__(self, detector):
        self.detector = detector
        self.crawler = DynamicCrawler()

    def can_handle(self, task):
        """
        Check if the agent can handle the given task.

        Args:
            task (dict): The task to be evaluated

        Returns:
            bool: True if the task is of type 'detect_gap', False otherwise
        """
        return task.get("type") == "detect_gap"

    def get_search_query(self, prompt, response):
        """
        Use the LLM to generate a focused search query for missing information.
        Args:
            prompt (str): The original user prompt.
            response (str): The current response.
        Returns:
            str: A search query string.
        """
        # Prompt the LLM to generate a search query for the missing info
        search_prompt = f"""
        You are an expert at formulating web search queries. Given the following user question and the current answer, generate a single, highly effective search query in Spanish that would help find the most relevant and up-to-date information missing from the answer. Only return the search query, nothing else.

        [User Question]
        {prompt}

        [Current Answer]
        {response}
        """
        try:
            messages = [{"role": "user", "content": search_prompt}]
            api_response = self.detector.client.chat(
                model="mistral-small",
                messages=messages,
                temperature=0.2
            )
            search_query = api_response.choices[0].message.content.strip()
            return search_query
        except Exception as e:
            print(f"Error generating search query: {e}")
            return prompt  # fallback to original prompt

    def duckduckgo_search_links(self, query, num_results=5):
        """
        Use the duckduckgo-search library to get relevant links for a query.
        Args:
            query (str): The search query.
            num_results (int): Number of links to extract.
        Returns:
            list: List of extracted URLs.
        """
        links = []
        with DDGS() as ddgs:
            for r in ddgs.text(query, max_results=num_results):
                if r.get('href'):
                    links.append(r['href'])
                if len(links) >= num_results:
                    break
        return links

    def handle(self, task, context):
        """
        Process the task to detect knowledge gaps in responses. If a gap is detected, use the LLM to generate a focused search query, then use duckduckgo-search, extract links, and use the crawler to update sources.

        Args:
            task (dict): Contains the prompt and response to analyze
            context (dict): Additional context information

        Returns:
            dict: Information about gap detection and actions taken.
        """
        prompt = task.get("prompt")
        response = task.get("response")
        gap_detected = self.detector.check_accuracy(prompt, response)
        if gap_detected:
            search_query = self.get_search_query(prompt, response)
            links = self.duckduckgo_search_links(search_query, num_results=5)
            if links:
                self.crawler.update_sources(links)
            return {
                "gap_detected": True,
                "search_query": search_query,
                "duckduckgo_links": links,
                "message": "Gap detected. Search query generated by LLM and links found via duckduckgo-search sent to crawler."
            }
        return {"gap_detected": False, "message": "No gap detected."}